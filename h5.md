# h5 - Alice and Bob

Computer hardware used to complete the assignment:

* CPU: AMD Ryzen 7 5800X
* GPU: AMD RX 6800 16GB
* RAM: 32 GB

***

## x) Read and summarize

### Schneier 2015: Applied Cryptography 

#### Chapter 1: Foundations, Section 1.1 Terminology

* Plainly readable text or data / Plaintext -> can be scrambled via methods of encryption -> results in a ciphertext -> can be decrypted to form the original plaintext. Provides confidentiality between a sender and a receiver.
* Authentication = the origin of a message / data must verifiable and non-falsifiable (sender can be verified).
* Integrity = the content of a message / data must verifiable and non-falsifiable (message verified to not be modified in transit).
* Nonrepudiation = the act of sending a message / data must verifiable and non-falsifiable (sender cant falsely deny sending a message for example).
* Modern cryptographic algorithms rely on keys for encryption and decryption.
* Symmetric algorithms = encryption and decryption key are usually the same, so called single-key algorithms.
* Asymmetric algorithms / Public-Key Algorithms = encryption key is different from decryption key. Encryption key often referred to as public key and decryption key as private key.

#### Chapter 2 - Protocol Building Blocks, Section 2.5 Communications Using Public-Key Cryptography

* Public-key cryptography described by Whitfield Diffie and Martin Hellman in 1976.
* The basic steps for communication using Public-key cryptography:
  1. Agreement to use public-key cryptosystem
  2. Receiver sends Sender their public key
  3. Sender encrypts data using receivers public keyand sends it receiver
  4. Receiver decrypts data sent by sender using their private key
* In real-world scenarios, public-key cryptography is most often used for securely sending symmetric algorithm keys, as they offer vastly better performance. This can be referred to as a hybrid cryptosystem
* Merkle's puzzles explored the problem of secure communication over insecure channels, by creating problems/challenges that were faster and easier to solve for the sender and receiver than for a third party.
* Digital signatures use same principles and algorithms for signing documents, though they also require a third party to either facilitate the signing or as an authority for verification purposes.

### Karvinen 2023: PGP - Send Encrypted and Signed Message - gpg

* The article outlines how to send a secret message securely over an internet connection using GNU privacy guard (gpg).
* The steps for doing so are a follows:
  1. Sender and receiver exchange public keys
  2. Sender and receiver verify that public keys belong to the other party
  3. After verification both parties sign each others public keys to mark them as trusted
  4. Sender signs the file using their own private key and encrypts it using receivers public key
  5. Receiver decrypts the message using their private key and verifies senders signature for authentication

## a) Pubkey today

The first use case of public key cryptography that comes to mind is email. I have set up and used digital signatures with my work email (Outlook) for quite some time. From what I understand (and after reading some of the Applied Cryptography by Schneier) the process works something like this to set up and use:
1. Retrieve / receive a certificate (private key) form a CA (certification authority)
2. Set up the certificate in Outlook settings and have it automatically sign sent emails
3. Send an email, hash is created from the email and that hash encrypted with my private key -> signature
4. Receiver gets email and signature.
5. Receiver verifies that the hash of the email and the hash of my signature decrypted with my public key (retrieved from CA) match, if they do the sender is verifyably me!

## b) Encrypt a message

For this part of the assignment, I decided to try using OpenSSL to encrypt a message. I used the Debian 13 VM we set up earlier for this. I started with updating my package list with:

``sudo apt-get update``

OpenSSL was already installed on the machine so I moved straight into encrypting a message with the following commands:

``echo "super secret message" | openssl enc -aes-256-cbc -a -pbkdf2 -pass pass:November123``

Where the

- ``echo "super secret message"`` is used to print my "super secret message" for usage by the following OpenSSL-command
- ``|`` used to chain multiple commands into a single command
- ``openssl enc`` OpenSSL encryption
- ``-aes-256-cbc`` Defines that we want to use the AES-256-CBC-algorithm for encryption
- ``-a`` Forces output to be base64 encoded
- ``-pbkdf2`` Used for better key derivation security
- ``-pass pass:November123`` Defines the key we use to encrypt the message

This gave us the following ciphertext:

``U2FsdGVkX18605ZP5+smeO8SOyXc92cqu07NlDgRtZUkRTMgxpg/RXxprkDhxOeR``

![](https://github.com/tommygratschew/cyber-security-autumn-2025/blob/main/images/h5p1.png "Encrypted message")

To decrypt the message we use the following command:

``echo "U2FsdGVkX18605ZP5+smeO8SOyXc92cqu07NlDgRtZUkRTMgxpg/RXxprkDhxOeR" | openssl enc -aes-256-cbc -a -d -pbkdf2 -pass pass:November123``

Which returns us the message we encrypted!



## c) Eve and Mallory

## d) Password management

## e) Refer to sources

## References

Karvinen 2025: Cyber Security - 2025 late autumn https://terokarvinen.com/cyber-security/

Schneier 2015: Applied Cryptography: Protocols, Algorithms and Source Code in C, 20th Anniversary Edition https://www.oreilly.com/library/view/applied-cryptography-protocols/9781119096726/

Karvinen 2023: PGP - Send Encrypted and Signed Message - gpg https://terokarvinen.com/2023/pgp-encrypt-sign-verify/

Rendek 2025: Using OpenSSL to Encrypt Messages and Files on Linux https://linuxconfig.org/using-openssl-to-encrypt-messages-and-files-on-linux
