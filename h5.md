# h5 - Alice and Bob

Computer hardware used to complete the assignment:

* CPU: AMD Ryzen 7 5800X
* GPU: AMD RX 6800 16GB
* RAM: 32 GB

***

## x) Read and summarize

### Schneier 2015: Applied Cryptography 

#### Chapter 1: Foundations, Section 1.1 Terminology

* Plainly readable text or data / Plaintext -> can be scrambled via methods of encryption -> results in a ciphertext -> can be decrypted to form the original plaintext. Provides confidentiality between a sender and a receiver.
* Authentication = the origin of a message / data must verifiable and non-falsifiable (sender can be verified).
* Integrity = the content of a message / data must verifiable and non-falsifiable (message verified to not be modified in transit).
* Nonrepudiation = the act of sending a message / data must verifiable and non-falsifiable (sender cant falsely deny sending a message for example).
* Modern cryptographic algorithms rely on keys for encryption and decryption.
* Symmetric algorithms = encryption and decryption key are usually the same, so called single-key algorithms.
* Asymmetric algorithms / Public-Key Algorithms = encryption key is different from decryption key. Encryption key often referred to as public key and decryption key as private key.

#### Chapter 2 - Protocol Building Blocks, Section 2.5 Communications Using Public-Key Cryptography

* Public-key cryptography described by Whitfield Diffie and Martin Hellman in 1976.
* The basic steps for communication using Public-key cryptography:
  1. Agreement to use public-key cryptosystem
  2. Receiver sends Sender their public key
  3. Sender encrypts data using receivers public keyand sends it receiver
  4. Receiver decrypts data sent by sender using their private key
* In real-world scenarios, public-key cryptography is most often used for securely sending symmetric algorithm keys, as they offer vastly better performance. This can be referred to as a hybrid cryptosystem
* Merkle's puzzles explored the problem of secure communication over insecure channels, by creating problems/challenges that were faster and easier to solve for the sender and receiver than for a third party.
* Digital signatures use same principles and algorithms for signing documents, though they also require a third party to either facilitate the signing or as an authority for verification purposes.

### Karvinen 2023: PGP - Send Encrypted and Signed Message - gpg

* The article outlines how to send a secret message securely over an internet connection using GNU privacy guard (gpg).
* The steps for doing so are a follows:
  1. Sender and receiver exchange public keys
  2. Sender and receiver verify that public keys belong to the other party
  3. After verification both parties sign each others public keys to mark them as trusted
  4. Sender signs the file using their own private key and encrypts it using receivers public key
  5. Receiver decrypts the message using their private key and verifies senders signature for authentication

## a) Pubkey today

The first use case of public key cryptography that comes to mind is email. I have set up and used digital signatures with my work email (Outlook) for quite some time. From what I understand (and after reading some of the Applied Cryptography by Schneier) the process works something like this to set up and use:
1. Retrieve / receive a certificate (private key) form a CA (certification authority)
2. Set up the certificate in Outlook settings and have it automatically sign sent emails
3. Send an email, hash is created from the email and that hash encrypted with my private key -> signature
4. Receiver gets email and signature.
5. Receiver verifies that the hash of the email and the hash of my signature decrypted with my public key (retrieved from CA) match, if they do the sender is verifyably me!

## b) Encrypt a message

For this part of the assignment, I decided to try using OpenSSL to encrypt a message. I used the Debian 13 VM we set up earlier for this. I started with updating my package list with:

``sudo apt-get update``

OpenSSL was already installed on the machine so I moved straight into encrypting a message with the following commands:

``echo "super secret message" | openssl enc -aes-256-cbc -a -pbkdf2 -pass pass:November123``

Where the

- ``echo "super secret message"`` is used to print my "super secret message" for usage by the following OpenSSL-command
- ``|`` used to chain multiple commands into a single command
- ``openssl enc`` OpenSSL encryption
- ``-aes-256-cbc`` Defines that we want to use the AES-256-CBC-algorithm for encryption
- ``-a`` Forces output to be base64 encoded
- ``-pbkdf2`` Used for better key derivation security
- ``-pass pass:November123`` Defines the key we use to encrypt the message

This gave us the following ciphertext:

``U2FsdGVkX18605ZP5+smeO8SOyXc92cqu07NlDgRtZUkRTMgxpg/RXxprkDhxOeR``

![](https://github.com/tommygratschew/cyber-security-autumn-2025/blob/main/images/h5p1.png "Encrypted message")

To decrypt the message we use the following command:

``echo "U2FsdGVkX18605ZP5+smeO8SOyXc92cqu07NlDgRtZUkRTMgxpg/RXxprkDhxOeR" | openssl enc -aes-256-cbc -a -d -pbkdf2 -pass pass:November123``

Where we gave the encrypted message as the input text and added the ``-d`` flag to indicate that we want to decrypt the message

Which returns us the message we encrypted!

![](https://github.com/tommygratschew/cyber-security-autumn-2025/blob/main/images/h5p2.png "Decrypted message")

In a hypothetical scenario where there was a sender and receiver the sender would generate a secret (in this case ``November123``) and give it to the receiver somehow alongside the information of encryption algorithm used etc. The sender would then use the secret to encrypt the message and send it to the receiver. The receiver could then use the predefined secret to decrypt the file. 

The security of this approach is rather poor, though that is to be expected for such a rudimentary approach. The Authenticity, Integrity and Nonrepudiation could be put into question as the secret wasn't sent using a public-key algorithm for example.

## c) Eve and Mallory

- Eve, how does PGP protect against passive eavesdropping
  
  1. Sender and receiver exchange public keys -> could be eavesdropped, but public information anyways.
  2. Verification process for public keys could also be eavesdropped, but doesnt matter as this is still regards only the public keys
  3. Encrypted message sent (``--encrypt`` & ``--recipient`` flags used), eavesdropper does not have the receivers private key -> cannot decrypt message
  4. Receiver decrypts the message on their end using their private key without the eavesdropper learning the contents!
     
- Mallory

  1. Sender and receiver exchange public keys, could be changed for example email changed for Mallorys public key. Verification through secondary channel takes care of this risk
  2. After verification both sender and receiver sign each others keys with ``--sign-key`` to mark them as trusted
  3. Sender encrypts and signs message with ``--encrypt``,``--recipient`` & ``--sign``
  4. Receiver decrypts and checks signature so that the message can be deemed as valid! Mallory can't change the message in between, because they don't have the receivers private key the decrypt or the senders private key to sign!
 
     
## d) Password management

I have used a couple of password managers for quite some time (probably started using one when I first had a password compromise many years back :-D, can't quite remember the specifics). 

- People not using password managers are extremely vulnerable in situations where a site they use has a data breach that leaks their passwords.
- Most often in my exprerience, people not using a password manager tend to recycle the same passwords on multiple sites and when one account goes it is only a matter of time before the rest do as well. Add to that the fact that you would need to remember all the sites you put that password in... Yikes.
- People are also very bad at creating secure passwords, something that a password manager does a lot better. Instead of November123 that you think is super secure, you get a bunch of gibberish that is actually much more secure!

![](https://github.com/tommygratschew/cyber-security-autumn-2025/blob/main/images/h5p3.png "Password Manager")

(Image of an example entry I created in F-secures password manager and the random password it gave for the entry.)

## e) Refer to sources

## References

Karvinen 2025: Cyber Security - 2025 late autumn https://terokarvinen.com/cyber-security/

Schneier 2015: Applied Cryptography: Protocols, Algorithms and Source Code in C, 20th Anniversary Edition https://www.oreilly.com/library/view/applied-cryptography-protocols/9781119096726/

Karvinen 2023: PGP - Send Encrypted and Signed Message - gpg https://terokarvinen.com/2023/pgp-encrypt-sign-verify/

Rendek 2025: Using OpenSSL to Encrypt Messages and Files on Linux https://linuxconfig.org/using-openssl-to-encrypt-messages-and-files-on-linux
